from __future__ import annotations

from typing import TYPE_CHECKING, Any, Dict, List, Optional, Set

if TYPE_CHECKING:  # pragma: no cover - type checking only
    from ..types import Slice, Resolution

"""
what is __future__ and why 'Slice' instead of Slice' and if TYPE_CHECKING. 

The class definition for Algorithm needs to know what things like Slice is to validate type hint. 
However, the actual import is outside in a different file. It's not imported at runtime. 
You'd get a NameError. 

When a type checker runs, it sees TYPE_CHECKING is True, executes the import, and learns that your string hints ("Slice", "Resolution") 
refer to classes found in the ..types module.
"""

class Algorithm:
    """
    Base class for creating quantitative trading strategies.
    """

    def __init__(self) -> None:
        self._cash: float = 10_000.0
        self._subscriptions: Set[str] = set()
        self._broker = None  # system engine thats runs algo sets this
        self._events: List[Dict[str, Any]] = []  # store log messages, errors, or custom events generated by the algorithm. list of dicts
        self.portfolio = self  # alias, calling itself portfolio
        self._current_time = None  # Track current time in backtest, system engine will do that. 

    def Initialize(self) -> None:
        """Called once before the event loop starts. Sets cash, subscribe to assets, set parameters, typically."""
        pass

    def OnData(self, data: "Slice") -> None:
        """Called for each bar with a Slice of data for subscribed symbols."""
        pass

    def SetCash(self, amount: float) -> None:
        """Set starting cash for the algorithm portfolio."""
        self._cash = float(amount)

    def AddEquity(self, symbol: str, resolution: "Resolution | None" = None) -> None:
        """Subscribe to an equity symbol at the given resolution (default daily)."""
        self._subscriptions.add(symbol)



    def place_order(
        self,
        symbol: str,
        quantity: int,
        is_buy: bool,
        order_type: str = "market",
        limit_price: Optional[float] = None,
    ) -> None:
        """Submit an order via the attached broker.

        Args:
            symbol: Stock symbol to trade
            quantity: Number of shares to trade
            is_buy: True to buy, False to sell
            order_type: "market" or "limit"
            limit_price: Required for limit orders
        """
        if self._broker is None:
            raise RuntimeError("Broker not attached")
        if order_type not in ("market", "limit"):
            raise ValueError("order_type must be 'market' or 'limit'")
        
        order: Dict[str, Any] = {
            "type": order_type,
            "symbol": symbol,
            "quantity": int(quantity),
            "is_buy": bool(is_buy),
            "limit_price": float(limit_price) if limit_price is not None else None,
        }
        self._broker.submit(order)



    def log(self, msg: str, **context: Any) -> None:
        event = {"level": "INFO", "msg": msg, **context}
        self._events.append(event)
    


    @property
    def total_portfolio_value(self) -> float:
        """Get total portfolio value (simplified implementation)."""
        return self._cash  # Simplified - in real implementation would include positions


