from __future__ import annotations

from typing import TYPE_CHECKING, Any, Dict, List, Optional, Set

if TYPE_CHECKING:  # pragma: no cover - type checking only
    from ..types import Slice, Resolution

"""
what is __future__ and why 'Slice' instead of Slice' and if TYPE_CHECKING. 

The class definition for Algorithm needs to know what things like Slice is to validate type hint. 
However, the actual import is outside in a different file. It's not imported at runtime. 
You'd get a NameError. 

When a type checker runs, it sees TYPE_CHECKING is True, executes the import, and learns that your string hints ("Slice", "Resolution") 
refer to classes found in the ..types module.
"""

class Algorithm:
    """
    Base class for creating quantitative trading strategies.
    """

    def __init__(self) -> None:
        self._cash: float = 10_000.0
        self._subscriptions: Set[str] = set()
        self._broker = None  # system engine thats runs algo sets this
        self._events: List[Dict[str, Any]] = []  # store log messages, errors, or custom events generated by the algorithm. list of dicts
        self.portfolio = self  # alias, calling itself portfolio
        self._current_time = None  # Track current time in backtest, system engine will do that. 

    def Initialize(self) -> None:
        """Called once before the event loop starts. Sets cash, subscribe to assets, set parameters, typically."""
        pass

    def OnData(self, data: "Slice") -> None:
        """Called for each bar with a Slice of data for subscribed symbols."""
        pass

    def SetCash(self, amount: float) -> None:
        """Set starting cash for the algorithm portfolio."""
        self._cash = float(amount)

    def AddEquity(self, symbol: str, resolution: "Resolution | None" = None) -> None:
        """Subscribe to an equity symbol at the given resolution (default daily)."""
        self._subscriptions.add(symbol)



    def place_order(
        self,
        symbol: str,
        weight: float,
        is_buy: bool,
        order_type: str = "market",
        limit_price: Optional[float] = None,
        current_price: Optional[float] = None,
    ) -> None:
        """Submit an order via the attached broker using portfolio percentage.

        Args:
            symbol: Stock symbol to trade
            weight: Portfolio percentage to allocate (0.0 to 1.0)
                   e.g., 0.25 = 25% of total portfolio value
            is_buy: True to buy, False to sell
            order_type: "market" or "limit"
            limit_price: Required for limit orders
            current_price: Current price (optional, will be auto-detected if not provided)
            
        Examples:
            self.place_order("AAPL", 0.20, is_buy=True)   # Allocate 20% to AAPL
            self.place_order("MSFT", 0.15, is_buy=False)  # Sell 15% worth of MSFT
        """
        if self._broker is None:
            raise RuntimeError("Broker not attached")
        if order_type not in ("market", "limit"):
            raise ValueError("order_type must be 'market' or 'limit'")
        if not 0.0 <= weight <= 1.0:
            raise ValueError("Weight must be between 0.0 and 1.0")
        
        # Get current portfolio value
        portfolio_snapshot = self._broker.snapshot()
        total_portfolio_value = portfolio_snapshot['total_equity']
        
        # Calculate dollar amount to trade
        dollar_amount = total_portfolio_value * weight
        
        # Get current price for the symbol
        if current_price is None:
            current_price = self._get_current_price(symbol)
        
        if current_price is None:
            # Try to get from current data if available
            current_price = getattr(self, '_current_prices', {}).get(symbol)
        
        if current_price is None:
            raise ValueError(f"Cannot get current price for {symbol}. Please provide current_price parameter.")
        
        # Calculate number of shares
        shares = int(dollar_amount / current_price)
        
        if shares <= 0:
            return  # Not enough money to buy even 1 share
        
        order: Dict[str, Any] = {
            "type": order_type,
            "symbol": symbol,
            "quantity": shares,
            "is_buy": bool(is_buy),
            "limit_price": float(limit_price) if limit_price is not None else None,
        }
        self._broker.submit(order)
    
    def _get_current_price(self, symbol: str) -> Optional[float]:
        """Get the current price for a symbol."""
        if self._broker is None:
            return None
        
        # Try to get from broker's last prices (populated during settlement)
        last_prices = getattr(self._broker, '_last_price', {})
        if symbol in last_prices:
            return last_prices[symbol]
        
        # Fallback: try to get from current holdings average price
        holdings = self._broker.holdings()
        if symbol in holdings:
            return holdings[symbol].average_price
        
        return None



    def log(self, msg: str, **context: Any) -> None:
        event = {"level": "INFO", "msg": msg, **context}
        self._events.append(event)
    


    @property
    def total_portfolio_value(self) -> float:
        """Get total portfolio value (simplified implementation)."""
        return self._cash  # Simplified - in real implementation would include positions


